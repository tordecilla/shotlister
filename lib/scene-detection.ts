import { exec } from 'child_process';
import { promisify } from 'util';
import { promises as fs } from 'fs';
import path from 'path';

const execAsync = promisify(exec);

export interface Scene {
  timestamp: number; // in seconds
  timecode: string; // HH:MM:SS.mmm
  screenshotPath: string;
  description?: string; // AI-generated scene description
}

/**
 * Convert seconds to HH:MM:SS.mmm format
 */
function formatTimecode(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${hours.toString().padStart(2, '0')}:${minutes
    .toString()
    .padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms
    .toString()
    .padStart(3, '0')}`;
}

/**
 * Parse timecode string (HH:MM:SS.mmm) to seconds
 */
function parseTimecode(timecode: string): number {
  const parts = timecode.split(':');
  const hours = parseInt(parts[0], 10);
  const minutes = parseInt(parts[1], 10);
  const seconds = parseFloat(parts[2]);

  return hours * 3600 + minutes * 60 + seconds;
}

/**
 * Detect scenes in a video using PySceneDetect
 */
export async function detectScenes(
  videoPath: string,
  uploadId: string,
  threshold: number = 3.0 // Adaptive threshold (lower = more scenes, default is 3.0)
): Promise<Scene[]> {
  const screenshotsDir = path.join(
    process.cwd(),
    'uploads',
    'scenes',
    uploadId
  );

  // Create screenshots directory
  await fs.mkdir(screenshotsDir, { recursive: true });

  console.log('Starting scene detection for:', videoPath);

  // Check if CSV already exists
  const csvPath = path.join(screenshotsDir, path.basename(videoPath, path.extname(videoPath)) + '-Scenes.csv');
  let csvExists = false;

  try {
    await fs.access(csvPath);
    csvExists = true;
    console.log('CSV already exists, skipping scene detection and parsing existing data');
  } catch {
    csvExists = false;
  }

  try {
    // Only run PySceneDetect if CSV doesn't exist
    if (!csvExists) {
      // Run PySceneDetect using python module
      // detect-adaptive is the best method for finding actual scene changes
      // -t sets the threshold (lower = more scenes, default is 3.0)
      const command = `python -m scenedetect -i "${videoPath}" -o "${screenshotsDir}" detect-adaptive -t ${threshold} list-scenes save-images -n 1`;

      console.log('Running PySceneDetect:', command);

      const { stderr } = await execAsync(command, {
        maxBuffer: 10 * 1024 * 1024, // 10MB buffer for large outputs
      });

      if (stderr) {
        console.log('PySceneDetect output:', stderr);
      }
    }

    // Parse the scene list CSV file generated by PySceneDetect

    let csvContent: string;
    try {
      csvContent = await fs.readFile(csvPath, 'utf-8');
    } catch (error) {
      console.log('No CSV file found, checking for scenes in output');
      // If no CSV, check if any images were created
      const files = await fs.readdir(screenshotsDir);
      const imageFiles = files.filter(f => f.endsWith('.jpg') || f.endsWith('.png'));

      if (imageFiles.length === 0) {
        console.log('No scenes detected in the video');
        return [];
      }

      // If we have images but no CSV, return empty array
      // This shouldn't happen but we handle it gracefully
      return [];
    }

    // Parse CSV: Skip both header lines (timecode list + column headers)
    const lines = csvContent.trim().split('\n').slice(2); // Skip 2 header lines
    const scenes: Scene[] = [];

    for (const line of lines) {
      if (!line.trim()) continue;

      // CSV format: Scene Number,Start Frame,Start Timecode,Start Time (seconds),End Frame,End Timecode,End Time (seconds),Length (frames),Length (timecode),Length (seconds)
      const columns = line.split(',');

      if (columns.length >= 4) {
        const sceneNumber = parseInt(columns[0].trim(), 10);
        const startTimecode = columns[2].trim();
        const startTimeSeconds = parseFloat(columns[3].trim());

        // Skip if parsing failed
        if (isNaN(sceneNumber) || isNaN(startTimeSeconds)) {
          continue;
        }

        // Screenshot filename pattern from PySceneDetect: {video}-Scene-{scene_num}-01.jpg
        const videoBasename = path.basename(videoPath, path.extname(videoPath));
        const screenshotFilename = `${videoBasename}-Scene-${sceneNumber.toString().padStart(3, '0')}-01.jpg`;
        const screenshotPath = `/uploads/scenes/${uploadId}/${screenshotFilename}`;

        scenes.push({
          timestamp: startTimeSeconds,
          timecode: startTimecode,
          screenshotPath,
        });
      }
    }

    console.log(`Scene detection complete. Found ${scenes.length} scenes.`);
    return scenes;
  } catch (error) {
    console.error('Scene detection error:', error);
    throw new Error(`Scene detection failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Extract a single screenshot at a specific timestamp (not used with PySceneDetect)
 */
export async function extractScreenshot(
  videoPath: string,
  timestamp: number,
  outputPath: string
): Promise<void> {
  // This function is kept for compatibility but not used with PySceneDetect
  // PySceneDetect automatically saves screenshots when detecting scenes
  throw new Error('extractScreenshot is not implemented for PySceneDetect. Use detectScenes instead.');
}
